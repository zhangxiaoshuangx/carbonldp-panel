{"version":3,"sources":["router.service.ts"],"names":[],"mappings":"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","file":"router.service.js","sourcesContent":["import { Location } from \"@angular/common\";\nimport { Router, Instruction } from \"@angular/router-deprecated\";\nimport { StringMapWrapper } from \"@angular/router-deprecated/src/facade/collection\";\nimport { isPresent, isBlank } from \"@angular/router-deprecated/src/facade/lang\";\n\n/**\n * Service that wraps router related functionality. This service must not be automatically injected,\n * because we need a different instance each time we inject it into a component (not a singleton).\n * Instead use a factory like:\n * <pre><code>\n *      provide( RouterService, {\n *          useFactory: ( router:Router ):RouterService => {\n *              return new RouterService( router );\n *          },\n *          deps: [ Router ]\n *      })\n * </pre></code>\n */\nexport class RouterService {\n\tprivate router:Router;\n\tprivate location:Location;\n\n\tconstructor( router:Router, location:Location ) {\n\t\tthis.router = router;\n\t\tthis.location = location;\n\t}\n\n\tisActive( route:any[] ):boolean {\n\t\tif( route.length === 0 ) return false;\n\n\t\tlet routeIsRelative:boolean = route[ 0 ].startsWith( \"./\" );\n\t\tlet instruction:Instruction = this.router.generate( route );\n\t\tlet router:Router = this.router;\n\t\tlet currentInstruction:Instruction = routeIsRelative ? router.currentInstruction : this.getRootRouter( router ).currentInstruction;\n\t\tif( isBlank( currentInstruction ) ) return false;\n\n\t\tlet currentInstructionBranch:Instruction[] = this.buildInstructionBranch( currentInstruction );\n\t\tlet instructionBranch:Instruction[] = this.buildInstructionBranch( instruction );\n\n\t\tif( instructionBranch.length > currentInstructionBranch.length ) return false;\n\n\t\tfor( let i:number = 0, length:number = instructionBranch.length; i < length; i ++ ) {\n\t\t\tlet instructionA:Instruction = instructionBranch[ i ];\n\t\t\tlet instructionB:Instruction = currentInstructionBranch[ i ];\n\t\t\tif( instructionA.component.routeName !== instructionB.component.routeName ) return false;\n\n\t\t\tif( ! this.compareInstructionParameters( instructionA, instructionB ) ) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate getRootRouter( router:Router ):Router {\n\t\twhile( isPresent( router.parent ) ) {\n\t\t\trouter = router.parent;\n\t\t}\n\t\treturn router;\n\t}\n\n\tprivate buildInstructionBranch( instruction:Instruction ):Instruction[] {\n\t\tlet instructionBranch:Instruction[] = [];\n\t\tlet currentInstruction:Instruction = instruction;\n\t\twhile( isPresent( currentInstruction ) ) {\n\t\t\tinstructionBranch.push( currentInstruction );\n\t\t\tcurrentInstruction = currentInstruction.child;\n\t\t}\n\n\t\tinstructionBranch.reverse();\n\t\treturn instructionBranch;\n\t}\n\n\tprivate compareInstructionParameters( instructionA:Instruction, instructionB:Instruction ):boolean {\n\t\tif( ! isPresent( instructionA.component.params ) && ! isPresent( instructionB.component.params ) ) return true;\n\t\tif( ! isPresent( instructionA.component.params ) || ! isPresent( instructionB.component.params ) ) return true;\n\n\t\tlet parametersAreEqual:boolean = true;\n\t\tStringMapWrapper.forEach( instructionA.component.params, ( value, key ) => {\n\t\t\tif( instructionB.component.params[ key ] !== value ) parametersAreEqual = false;\n\t\t} );\n\t\treturn parametersAreEqual;\n\t}\n}\n\nexport default RouterService;\n"],"sourceRoot":"/source/"}
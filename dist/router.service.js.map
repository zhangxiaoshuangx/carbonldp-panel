{"version":3,"sources":["router.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;YAGA,oEAAoE;YACpE,uFAAuF;YACvF,mFAAmF;YAEnF;;;;;;;;;;;;eAYG;YAEH;gBAEC,6BAA6B;gBAE7B,uBAAa,MAAa;oBACzB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;gBACtB,CAAC;gBAED,gCAAQ,GAAR,UAAU,MAAe,EAAE,KAAoB;oBAApB,qBAAoB,GAApB,YAAoB;oBAC9C,IAAI,SAAS,GAAU,EAAE,CAAC;oBAC1B,EAAE,CAAA,CAAE,OAAO,MAAM,KAAK,QAAS,CAAC,CAAC,CAAC;wBACjC,SAAS,GAAG,MAAM,CAAC;oBACpB,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACP,MAAM,CAAC,OAAO,CAAE,UAAE,KAAY,EAAE,GAAU;4BACzC,SAAS,IAAI,KAAK,CAAC;4BACnB,EAAE,CAAA,CAAE,GAAG,KAAK,MAAM,CAAC,MAAM,GAAG,CAAE,CAAC;gCAAA,SAAS,IAAI,GAAG,CAAC;wBACjD,CAAC,CAAE,CAAC;oBACL,CAAC;oBACD,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;gBACjD,CAAC;gBApBF;oBAAC,iBAAU,EAAE;;iCAAA;gBA4Eb,oBAAC;YAAD,CA3EA,AA2EC,IAAA;YA3ED,yCA2EC,CAAA;YAED,oBAAe,aAAa,EAAC","file":"router.service.js","sourcesContent":["// import { Location } from \"@angular/common\";\nimport { Router } from \"@angular/router\";\nimport { Injectable } from \"@angular/core\";\n// import { Router, Instruction } from \"@angular/router-deprecated\";\n// import { StringMapWrapper } from \"@angular/router-deprecated/src/facade/collection\";\n// import { isPresent, isBlank } from \"@angular/router-deprecated/src/facade/lang\";\n\n/**\n * Service that wraps router related functionality. This service must not be automatically injected,\n * because we need a different instance each time we inject it into a component (not a singleton).\n * Instead use a factory like:\n * <pre><code>\n *      provide( RouterService, {\n *          useFactory: ( router:Router ):RouterService => {\n *              return new RouterService( router );\n *          },\n *          deps: [ Router ]\n *      })\n * </pre></code>\n */\n@Injectable()\nexport class RouterService {\n\tprivate router:Router;\n\t// private location:Location;\n\n\tconstructor( router:Router ) {\n\t\tthis.router = router;\n\t}\n\n\tisActive( routes:string[], exact:boolean = true ):boolean {\n\t\tlet fullRoute:string = \"\";\n\t\tif( typeof routes === \"string\" ) {\n\t\t\tfullRoute = routes;\n\t\t} else {\n\t\t\troutes.forEach( ( value:string, idx:number )=> {\n\t\t\t\tfullRoute += value;\n\t\t\t\tif( idx !== routes.length - 1 )fullRoute += \"/\";\n\t\t\t} );\n\t\t}\n\t\treturn this.router.isActive( fullRoute, exact );\n\t}\n\n\t// isActive( route:any[] ):boolean {\n\t// \tif( route.length === 0 ) return false;\n\t//\n\t// \tlet routeIsRelative:boolean = route[ 0 ].startsWith( \"./\" );\n\t// \tlet instruction:Instruction = this.router.generate( route );\n\t// \tlet router:Router = this.router;\n\t// \tlet currentInstruction:Instruction = routeIsRelative ? router.currentInstruction : this.getRootRouter( router ).currentInstruction;\n\t// \tif( isBlank( currentInstruction ) ) return false;\n\t//\n\t// \tlet currentInstructionBranch:Instruction[] = this.buildInstructionBranch( currentInstruction );\n\t// \tlet instructionBranch:Instruction[] = this.buildInstructionBranch( instruction );\n\t//\n\t// \tif( instructionBranch.length > currentInstructionBranch.length ) return false;\n\t//\n\t// \tfor( let i:number = 0, length:number = instructionBranch.length; i < length; i ++ ) {\n\t// \t\tlet instructionA:Instruction = instructionBranch[ i ];\n\t// \t\tlet instructionB:Instruction = currentInstructionBranch[ i ];\n\t// \t\tif( instructionA.component.routeName !== instructionB.component.routeName ) return false;\n\t//\n\t// \t\tif( ! this.compareInstructionParameters( instructionA, instructionB ) ) return false;\n\t// \t}\n\t//\n\t// \treturn true;\n\t// }\n\t//\n\t// private getRootRouter( router:Router ):Router {\n\t// \twhile( isPresent( router.parent ) ) {\n\t// \t\trouter = router.parent;\n\t// \t}\n\t// \treturn router;\n\t// }\n\t//\n\t// private buildInstructionBranch( instruction:Instruction ):Instruction[] {\n\t// \tlet instructionBranch:Instruction[] = [];\n\t// \tlet currentInstruction:Instruction = instruction;\n\t// \twhile( isPresent( currentInstruction ) ) {\n\t// \t\tinstructionBranch.push( currentInstruction );\n\t// \t\tcurrentInstruction = currentInstruction.child;\n\t// \t}\n\t//\n\t// \tinstructionBranch.reverse();\n\t// \treturn instructionBranch;\n\t// }\n\t//\n\t// private compareInstructionParameters( instructionA:Instruction, instructionB:Instruction ):boolean {\n\t// \tif( ! isPresent( instructionA.component.params ) && ! isPresent( instructionB.component.params ) ) return true;\n\t// \tif( ! isPresent( instructionA.component.params ) || ! isPresent( instructionB.component.params ) ) return true;\n\t//\n\t// \tlet parametersAreEqual:boolean = true;\n\t// \tStringMapWrapper.forEach( instructionA.component.params, ( value, key ) => {\n\t// \t\tif( instructionB.component.params[ key ] !== value ) parametersAreEqual = false;\n\t// \t} );\n\t// \treturn parametersAreEqual;\n\t// }\n}\n\nexport default RouterService;"],"sourceRoot":"/source/"}
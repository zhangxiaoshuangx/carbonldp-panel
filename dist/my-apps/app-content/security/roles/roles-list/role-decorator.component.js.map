{"version":3,"sources":["my-apps/app-content/security/roles/roles-list/role-decorator.component.ts"],"names":[],"mappings":";;;IAQA,gBAAgB;IAChB,+CAA+C;IAC/C,4BAA4B;IAC5B,6BAA6B;IAC7B,EAAE;IACF,sDAAsD;IACtD,mDAAmD;IACnD,qDAAqD;IACrD,KAAK;IACL,EAAE;IACF,yHAAyH;IACzH,iBAAiB;IACjB,KAAK;IACL,IAAI;IAGJ,yDAAyD;IACzD,qFAAqF;IACrF,6EAA6E;IAC7E,6GAA6G;IAC7G,+EAA+E;IAC/E,0EAA0E;IAC1E,8DAA8D;IAC9D,uDAAuD;IACvD,QAAQ;IACR,KAAK;IAEL,0FAA0F;IAC1F,oEAAoE;IACpE,aAAa;IACb,aAAa;IACb,+FAA+F;IAC/F,MAAM;IACN,YAAY;IACZ,uCAAuC;IACvC,KAAK;IAGL,8BAA8B;IAE9B,aAAqB,MAAc;QAClC,MAAM,CAAC,UAAE,MAAM;YACd,kDAAkD;YAClD,yBAAyB;YACzB,EAAE;YACF,yDAAyD;YACzD,4CAA4C;YAC5C,4BAA4B;YAC5B,4CAA4C;YAC5C,MAAM;YACN,wCAAwC;YACxC,mBAAmB;YACnB,IAAI;YACJ,EAAE;YACF,kCAAkC;YAClC,oCAAoC;YACpC,0CAA0C;YAC1C,uCAAuC;YACvC,KAAK;YACL,EAAE;YACF,uDAAuD;YACvD,oCAAoC;YACpC,EAAE;YACF,qDAAqD;YACrD,YAAY;YACZ,OAAO,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC;QACvB,CAAC,CAAC;IACH,CAAC;IA3BD,qBA2BC,CAAA;;;;;;;AAGD,4BAA4B","file":"role-decorator.component.js","sourcesContent":["import { Injectable } from \"@angular/core\";\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from \"@angular/router\";\nimport { Observable } from \"rxjs\";\n\nimport * as boot from \"angular2-carbonldp/boot\";\nimport { AuthService } from \"angular2-carbonldp/services\";\n\n\n// @Injectable()\n// class RoleDecorator implements CanActivate {\n// \tprivate authService:any;\n// \tprivate contextToken:any;\n//\n// \tconstructor( authService:any, contextToken:any ) {\n// \t\tconsole.log( \"AuthService: %o\", authService );\n// \t\tconsole.log( \"ContextToken: %o\", contextToken );\n// \t}\n//\n// \tcanActivate( route:ActivatedRouteSnapshot, state:RouterStateSnapshot ):Observable<boolean>|Promise<boolean>|boolean {\n// \t\treturn true;\n// \t}\n// }\n\n\n// export const Roles = ( ...rolesAllowed:string[] ) => {\n// \treturn CanActivate( ( next:ComponentInstruction, prev:ComponentInstruction ) => {\n// \t\t//this would not work if user info was not being kept in session storage\n// \t\t//as of now it doesn't seem possible to access same-instance application services through non-components\n// \t\tconst injector = Injector.resolveAndCreate( [ Authentication, Storage ] );\n// \t\tconst authentication:Authentication = injector.get( Authentication );\n// \t\tconst userRoles:Array<string> = authentication.userRoles;\n// \t\treturn isAllowedAccess( rolesAllowed, userRoles );\n// \t} );\n// };\n\n// const isAllowedAccess = ( rolesAllowed:Array<string>, currentRoles:Array<string> ) => {\n// \tconst intersectedRoles = currentRoles.reduce( ( acc, curr ) => {\n// \t\treturn [\n// \t\t\t...acc,\n// \t\t\t...rolesAllowed.filter( role => role.trim().toUpperCase() === curr.trim().toUpperCase() )\n// \t\t]\n// \t}, [] );\n// \treturn intersectedRoles.length > 0;\n// };\n\n\n// START: TEST WITH DECORATORS\n\nexport function Log( prefix?:string ) {\n\treturn ( target ) => {\n\t\t// // save a reference to the original constructor\n\t\t// let original = target;\n\t\t//\n\t\t// // a utility function to generate instances of a class\n\t\t// function construct( constructor, args ) {\n\t\t// \tlet c:any = function() {\n\t\t// \t\treturn constructor.apply( this, args );\n\t\t// \t};\n\t\t// \tc.prototype = constructor.prototype;\n\t\t// \treturn new c();\n\t\t// }\n\t\t//\n\t\t// // the new constructor behavior\n\t\t// let f:any = function( ...args ) {\n\t\t// \tconsole.log( prefix + original.name );\n\t\t// \treturn construct( original, args );\n\t\t// };\n\t\t//\n\t\t// // copy prototype so instanceof operator still works\n\t\t// f.prototype = original.prototype;\n\t\t//\n\t\t// // return new constructor (will override original)\n\t\t// return f;\n\t\tconsole.log( target );\n\t};\n}\n\n\n// END: TEST WITH DECORATORS"]}